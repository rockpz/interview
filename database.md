# 数据库

## 关系数据库范式

第一范式：每个属性都不可再分
第二范式：每个表必须有且仅有一个数据元素为主键(Primary key),其他属性需完全依赖于主键(表中不能有无关数据)
第三范式：第三范式在第二范式的基础上，消除了非主属性对于码的传递函数依赖(不要有数据冗余)

1: 性能原因，没有任何冗余的表设计会产生更多的查询行为，这意味着会产生更多次的数据库IO操作。在一些实时交互的系统中，可能会慢得让人难以忍受。
2: 当然，你可以使用数据库的 连接(join) 操作，而事实上数据库提供 join 也就是为了来缓解这种问题。但一旦用到了分库分表方案的面前，这个问题就会非常的棘手。
成本结构的变化，数据库范式是在20世纪提出的，当时的磁盘存储成本还很高。随着科技发展，数据存储的成本已经大幅度缩减，对于采用范式设计(规避冗余)带来的成本缩减收益已经不那么明显。

电表是否告警异常 跳闸 有租客
按房源名模糊搜索工单，做分页
模糊查询

范式是为了消除冗余，那么反范式就是通过增加冗余、聚合的手段来提升性能。

## 事务

## 锁

## 索引

https://zhuanlan.zhihu.com/p/113917726

普通索引
唯一索引
复合索引 最左原则
索引是一种为了帮助数据库系统高效获取数据而由其维护着的满足特定查找算法的数据结构。
传统磁盘I/O速度相对于主存要慢上若干个数量级(一般是5个)，所以涉及磁盘的查找我们必须想办法减少磁盘I/O次数

B+ Tree索引和Hash索引区别
哈希索引适合等值查询，但是不无法进行范围查询 哈希索引没办法利用索引完成排序 哈希索引不支持多列联合索引的最左匹配规则 如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题

## Nosql

## postgresql与mysql的区别

## 红黑树为什么不适合做索引

红黑树并没有完全解决二叉查找树虽然这个“右倾”趋势远没有二叉查找树退化为线性链表那么夸张，但是数据库中的基本主键自增操作，主键一般都是数百万数千万的，如果红黑树存在这种问题，对于查找性能而言也是巨大的消耗，我们数据库不可能忍受这种无意义的等待的。

AVL树是更为严格的自平衡二叉树，它是个绝对平衡的二叉树，因此他在调整二叉树的形态上消耗的性能会更多。AVL 树顺序插入 1~16 个节点，查找 id=16 需要比较的节点数为 4。从查找效率而言，AVL 树查找的速度要高于红黑树的查找效率（AVL 树是 4 次比较，红黑树是 6 次比较）。从树的形态看来，AVL 树不存在红黑树的“右倾”问题。也就是说，大量的顺序插入不会导致查询性能的降低，这从根本上解决了红黑树的问题。

看起来 AVL 树作为数据查找的数据结构确实很不错，但是 AVL 树并不适合做 Mysql 数据库的索引数据结构，因为考虑一下这个问题：
数据库查询数据的瓶颈在于磁盘 IO，如果使用的是 AVL 树，我们每一个树节点只存储了一个数据，我们一次磁盘 IO 只能取出来一个节点上的数据加载到内存里，那比如查询 id=7 这个数据我们就要进行磁盘 IO 三次，这是多么消耗时间的。所以我们设计数据库索引时需要首先考虑怎么尽可能减少磁盘 IO 的次数。
磁盘 IO 有个有个特点，就是从磁盘读取 1B 数据和 1KB 数据所消耗的时间是基本一样的，我们就可以根据这个思路，我们可以在一个树节点上尽可能多地存储数据，一次磁盘 IO 就多加载点数据到内存，这就是 B 树，B+树的的设计原理了。

AVL优点
不错的查找性能（O（logn）），不存在极端的低效查找的情况。
可以实现范围查找、数据排序。

B树的目的为了硬盘快速读取数据（降低IO操作次树）而设计的一种平衡的多路查找树。目前大多数据库及文件索引，都是使用B树或变形来存储实现。

## mysql innodb

mysql8 新增特性
NOWAIT:     请求行被其他事务锁定的情况下立即返回语句
SKIP LOCK:  从结果集中删除被锁定的行

B树特性：
. 每个结点最多m个子结点
. 除了根结点和叶子结点外，每个结点最少有m/2(向上取整)个子结点
. 如果根结点不是叶子结点，那根结点至少包含两个子结点
. 所有的叶子结点都位于同一层
. 每个结点都包含k个元素(关键字),这里m/2 >= k
. 每个结点中的元素(关键字)从小到大排列
. 每个元素(关键字)子左结点的值都小于或等于该元素(关键字)。右结点的值都大于或等于该元素(关键字)。

## 事务

ACID
原子性 atomicity
一致性 consistency
隔离性 isolation 每个读写事务的对象对其他事务的操作对象能互相分离
持久性 durability

mysql事务隔离级别
READ COMMITTED    提交读，解决脏读问题，一个事务开始之后，只能看到自己提交的事务所做的修改，不可重复读
READ UNCOMMITTED  未提交读，未解决并发问题，事务未提交对其他事务也是可见的，会出现脏读问题
REPEATABLE READ   可重复读，一个事务开始之后，只能看到自己提交的事务所做的修改，不可重复读，这种隔离级别未定义解决幻读的问题
SERIALIZABLE      串行化，解决所有问题，最高的隔离级别

事务中的隔离性由锁实现，原子性、一致性和持久性由数据库的redo log 和 undo log来实现

脏读 幻读
InnoDB 引擎默认的事务隔离级别是可重复读, 通过锁、MVCC解决幻读问题